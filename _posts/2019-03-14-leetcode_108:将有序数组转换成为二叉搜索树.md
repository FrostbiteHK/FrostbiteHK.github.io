---
layout:     post
title:      leetcode刷题
subtitle:   将有序数组转换成为二叉搜索树
date:       2019-03-14
author:     HK
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - leetcode(simple)
---
# leetcode刷题记录
## 将有序数组转换成为二叉搜索树

#### 题目描述：
将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。<br>

本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。<br>

*示例:*<br>

给定有序数组: [-10,-3,0,5,9],一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：

          0
         / \
       -3   9
       /   /
     -10  5
     
#### 解题思路：
*概念* 
* 平衡二叉树：空树或者它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树也都是平衡树。
* 二叉搜索树：空树或者二叉树的所有节点比他的左子节点大，比他的右子节点小。
由于输入的是有序数组，只需要从中间对分，中间数作为根节点，左侧数组为左子树，右侧数组为右子树，此时左右子树结点数目最多相差1个，再依次递归左右子树。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return nums == null ? null : buildTree(nums, 0, nums.length - 1);
    }
    
    private TreeNode buildTree(int[] nums, int L, int R){
        if(L > R) return null;
        int M = L + (R - L) / 2;
        TreeNode root = new TreeNode(nums[M]);
        root.left = buildTree(nums, L, M - 1);
        root.right = buildTree(nums, M + 1, R);
        return root;
    }
}
```
