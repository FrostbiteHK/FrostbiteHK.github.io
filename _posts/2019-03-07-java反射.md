---
layout:     post
title:      Java编程技巧
subtitle:   反射
date:       2019-03-07
author:     HK
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - Java
---
# 详解Java中的反射
### 理解Class类
&emsp;针对某个类而言，这个类的数据成员名、方法和构造器、这个类到底实现了哪些接口，JRE 都为其保留一个不变的 Class 类型的对象。
一个 Class 对象包含了特定某个类的有关信息。

Class对象只能由系统建立对象<br>
一个类在JVM中只会有一个Class实例<br>
每个类的实例都会记得自己是由哪个Class类的实例所生成的。<br>
#### Class是什么？
Class是一个类
```Java
public class ReflectionTest {
    @Test
    public void testClass() {
       Class clazz = null;
    }
}


//Class的定义
public final
    class Class<T> implements java.io.Serializable,
                              java.lang.reflect.GenericDeclaration,
                              java.lang.reflect.Type,
                              java.lang.reflect.AnnotatedElement {

.....
.....
.....
}
//小写class表示是一个类类型，大写Class表示这个类的名称
```
#### Class类封装了哪些信息？
  &emsp;Class类封装了当前对象所对应的类的信息，包括类名，属性，方法，构造器等。
``` Java
package com.atguigu.java.fanshe;

//定义一个Person类
public class Person {
    String name;
    private int age;
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
    
    //包含一个带参的构造器和一个不带参的构造器
    public Person(String name, int age) {
        super();
        this.name = name;
        this.age = age;
    }
    public Person() {
        super();
    }

}

```
通过Class类获取类对象
```java
public class ReflectionTest {
    @Test
    public void testClass() {
       Class clazz = null;
       
       //1.得到Class对象
       clazz = Person.class;     
    }
}
```
同样可以获取属性值
```java
public class ReflectionTest {
    @Test
    public void testClass() {
       Class clazz = null;
       
       //1.得到Class对象
       clazz = Person.class;
       //2.返回字段的数组
       Field[] fields = clazz.getDeclaredFields();
    }
}
```

### 获取Class对象的三种方式
　　1.通过类名获取      类名.class <br>   
　　2.通过对象获取      对象名.getClass()<br>
　　3.通过全类名获取    Class.forName(全类名)<br>
``` java
public class ReflectionTest {
    @Test
    public void testClass() throws ClassNotFoundException {
       Class clazz = null;
       
       //1.通过类名
       clazz = Person.class;
       

       //2.通过对象名
       //这种方式是用在传进来一个对象，却不知道对象类型的时候使用
       Person person = new Person();
       clazz = person.getClass();
       //上面这个例子的意义不大，因为已经知道person类型是Person类，再这样写就没有必要了
       //如果传进来是一个Object类，这种做法就是应该的
       Object obj = new Person();
       clazz = obj.getClass();
       

       //3.通过全类名(会抛出异常)
       //一般框架开发中这种用的比较多，因为配置文件中一般配的都是全类名，通过这种方式可以得到Class实例
       String className=" com.atguigu.java.fanshe.Person";
       clazz = Class.forName(className);       
       


       
       //字符串的例子
       clazz = String.class;
       
       clazz = "javaTest".getClass();
       
       clazz = Class.forName("java.lang.String");
       
       System.out.println(); 
    }
}
```
#### Class类的常用方法

| 方法名 | 功能说明 |
| ------ | ------ |
| static Class forName(String name) | 返回指定类名 name 的 Class 对象 | 
| Object newInstance() | 调用缺省构造函数，返回该Class对象的一个实例 | 
| Object newInstance(Object []args)) | 调用当前格式构造函数，返回该Class对象的一个实例 | 
| getName() | 返回此Class对象所表示的实体（类、接口、数组类、基本类型或void）名称 | 
| Class getSuperClass() | 返回当前Class对象的父类的Class对象 | 
| Class [] getInterfaces() | 获取当前Class对象的接口 | 
| ClassLoader getClassLoader() | 返回该类的类加载器 | 
| Class getSuperclass() | 返回表示此Class所表示的实体的超类的Class | 

Class类的newInstance()方法
``` java
public void testNewInstance() throws ClassNotFoundException, InstantiationException, IllegalAccessException{
        //1.获取Class对象
        String className="com.atguigu.java.fanshe.Person";
        Class clazz = Class.forName(className);  
        
        //利用Class对象的newInstance方法创建一个类的实例
        Object obj =  clazz.newInstance();
        System.out.println(obj);
    }
    //结果是：com.atguigu.java.fanshe.Person@2866bb78
```
&emsp;可以看出确实是创建了一个Person实例，但是Person类有两个构造方法，到底是调用的哪一个构造方法呢？<br>
　实际调用的是**类的无参数的构造器**。所以在我们在定义一个类的时候，定义一个有参数的构造器，作用是对属性进行初始化，还要写一个无参数的构造器，
作用就是反射时侯用。**一般地、一个类若声明一个带参的构造器，同时要声明一个无参数的构造器。**

### ClassLoader
类装载器是用来把类(class)装载进 JVM 的。JVM 规范定义了两种类型的类装载器：启动类装载器(bootstrap)和用户自定义装载器(user-defined class loader)。 
JVM在运行时会产生3个类加载器组成的初始化加载器层次结构 ，如下图所示：
![加载器层次结构 ](https://images0.cnblogs.com/blog/534926/201401/181711178455.jpg)

```java
public class ReflectionTest {
    @Test
    public void testClassLoader() throws ClassNotFoundException, FileNotFoundException{
        //1. 获取一个系统的类加载器(可以获取，当前这个类PeflectTest就是它加载的)
        ClassLoader classLoader = ClassLoader.getSystemClassLoader();
        System.out.println(classLoader);
        

        //2. 获取系统类加载器的父类加载器（扩展类加载器，可以获取）. 
        classLoader = classLoader.getParent();
        System.out.println(classLoader); 
        

        //3. 获取扩展类加载器的父类加载器（引导类加载器，不可获取）.
        classLoader = classLoader.getParent();
        System.out.println(classLoader);
        

        //4. 测试当前类由哪个类加载器进行加载（系统类加载器）: 
        classLoader = Class.forName("com.atguigu.java.fanshe.ReflectionTest")
             .getClassLoader();
        System.out.println(classLoader);
    

        //5. 测试 JDK 提供的 Object 类由哪个类加载器负责加载（引导类）
        classLoader = Class.forName("java.lang.Object")
                 .getClassLoader();
        System.out.println(classLoader); 
    }
}
//结果：
//sun.misc.Launcher$AppClassLoader@5ffdfb42
//sun.misc.Launcher$ExtClassLoader@1b7adb4a
//null
//sun.misc.Launcher$AppClassLoader@5ffdfb42
//null
```

#### 使用类加载器获取当前类目录下的文件
　　首先，系统类加载器可以加载当前项目src目录下面的所有类，如果文件也放在src下面，也可以用类加载器来加载。
　　调用 **getResourceAsStream** 获取类路径下的文件对应的输入流.
  ![使用类加载器获取当前类目录的文件](https://images0.cnblogs.com/blog/534926/201401/181739102057.jpg)
  ![文件目录结构](https://images0.cnblogs.com/blog/534926/201401/181747533770.jpg)
  ```java
public class ReflectionTest {
    @Test
    public void testClassLoader() throws FileNotFoundException{
        //src目录下，直接加载
        InputStream in1 = null;
        in1 = this.getClass().getClassLoader().getResourceAsStream("test1.txt");
        
        //放在内部文件夹，要写全路径
        InputStream in2 = null;
        in2 = this.getClass().getClassLoader().getResourceAsStream("com/atguigu/java/fanshe/test2.txt");
    }
}
  ```
  
  ### 反射
  #### 反射概述
  Reflection（反射）是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的內部信息，并能直接操作任意对象的内部属性及方法　
  Java反射机制主要提供了以下功能：
+ 在运行时构造任意一个类的对象<br>
+ 在运行时获取任意一个类所具有的成员变量和方法<br>
+ 在运行时调用任意一个对象的方法（属性）<br>
+ 生成动态代理<br>
 
　　Class 是一个类; 一个描述类的类.
　　封装了描述方法的** Method**,
              描述字段的 **Filed**,
              描述构造器的 **Constructor** 等属性.
   
  #### 如何描述方法
  ```java
  public class ReflectionTest {
    @Test
    public void testMethod() throws Exception{
        Class clazz = Class.forName("com.atguigu.java.fanshe.Person");
        
        //
        //1.获取方法
      //  1.1 获取取clazz对应类中的所有方法--方法数组（一）
        //     不能获取private方法,且获取从父类继承来的所有方法
        Method[] methods = clazz.getMethods();
        for(Method method:methods){
            System.out.print(" "+method.getName());
        }
        System.out.println();
        
        //
        //  1.2.获取所有方法，包括私有方法 --方法数组（二）
        //  所有声明的方法，都可以获取到，且只获取当前类的方法
        methods = clazz.getDeclaredMethods();
        for(Method method:methods){
            System.out.print(" "+method.getName());
        }
        System.out.println();
        
        //
        //  1.3.获取指定的方法
        //  需要参数名称和参数列表，无参则不需要写
        //  对于方法public void setName(String name) {  }
        Method method = clazz.getDeclaredMethod("setName", String.class);
        System.out.println(method);
        //  而对于方法public void setAge(int age) {  }
        method = clazz.getDeclaredMethod("setAge", Integer.class);
        System.out.println(method);
        //  这样写是获取不到的，如果方法的参数类型是int型
        //  如果方法用于反射，那么要么int类型写成Integer： public void setAge(Integer age) {  }
　　　　 //  要么获取方法的参数写成int.class
        
        //
        //2.执行方法
        //  invoke第一个参数表示执行哪个对象的方法，剩下的参数是执行方法时需要传入的参数
        Object obje = clazz.newInstance();
        method.invoke(obje,2);

　　　　//如果一个方法是私有方法，第三步是可以获取到的，但是这一步却不能执行
　　　　//私有方法的执行，必须在调用invoke之前加上一句method.setAccessible（true）;
    }
}
  ```
  主要用到的两个方法
```java
  /**
         * @param name the name of the method
         * @param parameterTypes the list of parameters
         * @return the {@code Method} object that matches the specified
         */
        public Method getMethod(String name, Class<?>... parameterTypes){
            
        }
        
        /**
         * @param obj  the object the underlying method is invoked from
         * @param args the arguments used for the method call
         * @return  the result of dispatching the method represented by
         */
        public Object invoke(Object obj, Object... args){
            
        }
```

#### 自定义工具方法
   自定义一个方法：1.把类对象和类方法名作为参数，执行方法   2.把全类名和方法名作为参数，执行方法
　比如Person里有一个方法
 ```java
 public void test(String name,Integer age){
        System.out.println("调用成功");
    }
 ```
 那么我们自定义一个方法：**1.把类对象和类方法名作为参数，执行方法**
```java
 /**
     * 
     * @param obj: 方法执行的那个对象. 
     * @param methodName: 类的一个方法的方法名. 该方法也可能是私有方法. 
     * @param args: 调用该方法需要传入的参数
     * @return: 调用方法后的返回值
     *  
     */
      public Object invoke(Object obj, String methodName, Object ... args) throws Exception{
        //1. 获取 Method 对象
        //   因为getMethod的参数为Class列表类型，所以要把参数args转化为对应的Class类型。
        
        Class [] parameterTypes = new Class[args.length];
        for(int i = 0; i < args.length; i++){
            parameterTypes[i] = args[i].getClass();
            System.out.println(parameterTypes[i]); 
        }
        
        Method method = obj.getClass().getDeclaredMethod(methodName, parameterTypes);
        //如果使用getDeclaredMethod，就不能获取父类方法，如果使用getMethod，就不能获取私有方法
　　　　
　　　　　//
　　　　　//2. 执行 Method 方法
        //3. 返回方法的返回值
        return method.invoke(obj, args);
      }
```
调用：
```java
      @Test
        public void testInvoke() throws Exception{
            Object obj = new Person();            
            invoke(obj, "test", "wang", 1);             
        }
```
这样就通过对象名，方法名，方法参数执行了该方法.

**2.把全类名和方法名作为参数，执行方法**
```java
/**
         * @param className: 某个类的全类名
         * @param methodName: 类的一个方法的方法名. 该方法也可能是私有方法. 
         * @param args: 调用该方法需要传入的参数
         * @return: 调用方法后的返回值
         */
        public Object invoke(String className, String methodName, Object ... args){
            Object obj = null;
            
            try {
                obj = Class.forName(className).newInstance();
                //调用上一个方法
                return invoke(obj, methodName, args);
            }catch(Exception e) {
                e.printStackTrace();
            }            
            return null;
        }
 ```
 调用：
```java
         public void testInvoke() throws Exception{
                
            invoke("com.atguigu.java.fanshe.Person", 
                    "test", "zhagn", 12);         
        }
　　
 // 使用系统方法（前提是此类有一个无参的构造器（查看API））
@Test
        public void testInvoke() throws Exception{
            Object result = 
                    invoke("java.text.SimpleDateFormat", "format", new Date());
            System.out.println(result);          
        }
```
**这种反射实现的主要功能是可配置和低耦合。只需要类名和方法名，而不需要一个类对象就可以执行一个方法。
如果我们把全类名和方法名放在一个配置文件中，就可以根据调用配置文件来执行方法。**
